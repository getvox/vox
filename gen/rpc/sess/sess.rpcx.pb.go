// Code generated by protoc-gen-rpcx. DO NOT EDIT.
// versions:
// - protoc-gen-rpcx v0.3.0
// - protoc          (unknown)
// source: rpc/sess/sess.proto

package sess

import (
	context "context"
	client "github.com/smallnest/rpcx/client"
	protocol "github.com/smallnest/rpcx/protocol"
	server "github.com/smallnest/rpcx/server"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = context.TODO
var _ = server.NewServer
var _ = client.NewClient
var _ = protocol.NewMessage

// ================== interface skeleton ===================
type SessAble interface {
	// SessAble can be used for interface verification.

	// Login is server rpc method as defined
	Login(ctx context.Context, args *LoginReq, reply *LoginRsp) (err error)

	// Logout is server rpc method as defined
	Logout(ctx context.Context, args *LogoutReq, reply *LogoutRsp) (err error)

	// Disconnect is server rpc method as defined
	Disconnect(ctx context.Context, args *DisconnectReq, reply *DisconnectRsp) (err error)

	// Heartbeat is server rpc method as defined
	Heartbeat(ctx context.Context, args *HeartbeatReq, reply *HeartbeatRsp) (err error)

	// GetOnline is server rpc method as defined
	GetOnline(ctx context.Context, args *GetOnlineReq, reply *GetOnlineRsp) (err error)
}

// ================== server skeleton ===================
type SessImpl struct{}

// ServeForSess starts a server only registers one service.
// You can register more services and only start one server.
// It blocks until the application exits.
func ServeForSess(addr string) error {
	s := server.NewServer()
	s.RegisterName("Sess", new(SessImpl), "")
	return s.Serve("tcp", addr)
}

// Login is server rpc method as defined
func (s *SessImpl) Login(ctx context.Context, args *LoginReq, reply *LoginRsp) (err error) {
	// TODO: add business logics

	// TODO: setting return values
	*reply = LoginRsp{}

	return nil
}

// Logout is server rpc method as defined
func (s *SessImpl) Logout(ctx context.Context, args *LogoutReq, reply *LogoutRsp) (err error) {
	// TODO: add business logics

	// TODO: setting return values
	*reply = LogoutRsp{}

	return nil
}

// Disconnect is server rpc method as defined
func (s *SessImpl) Disconnect(ctx context.Context, args *DisconnectReq, reply *DisconnectRsp) (err error) {
	// TODO: add business logics

	// TODO: setting return values
	*reply = DisconnectRsp{}

	return nil
}

// Heartbeat is server rpc method as defined
func (s *SessImpl) Heartbeat(ctx context.Context, args *HeartbeatReq, reply *HeartbeatRsp) (err error) {
	// TODO: add business logics

	// TODO: setting return values
	*reply = HeartbeatRsp{}

	return nil
}

// GetOnline is server rpc method as defined
func (s *SessImpl) GetOnline(ctx context.Context, args *GetOnlineReq, reply *GetOnlineRsp) (err error) {
	// TODO: add business logics

	// TODO: setting return values
	*reply = GetOnlineRsp{}

	return nil
}

//================== client stub ===================
// Sess is a client wrapped XClient.
type SessClient struct {
	xclient client.XClient
}

// NewSessClient wraps a XClient as SessClient.
// You can pass a shared XClient object created by NewXClientForSess.
func NewSessClient(xclient client.XClient) *SessClient {
	return &SessClient{xclient: xclient}
}

// NewXClientForSess creates a XClient.
// You can configure this client with more options such as etcd registry, serialize type, select algorithm and fail mode.
func NewXClientForSess(addr string) (client.XClient, error) {
	d, err := client.NewPeer2PeerDiscovery("tcp@"+addr, "")
	if err != nil {
		return nil, err
	}

	opt := client.DefaultOption
	opt.SerializeType = protocol.ProtoBuffer

	xclient := client.NewXClient("Sess", client.Failtry, client.RoundRobin, d, opt)

	return xclient, nil
}

// Login is client rpc method as defined
func (c *SessClient) Login(ctx context.Context, args *LoginReq) (reply *LoginRsp, err error) {
	reply = &LoginRsp{}
	err = c.xclient.Call(ctx, "Login", args, reply)
	return reply, err
}

// Logout is client rpc method as defined
func (c *SessClient) Logout(ctx context.Context, args *LogoutReq) (reply *LogoutRsp, err error) {
	reply = &LogoutRsp{}
	err = c.xclient.Call(ctx, "Logout", args, reply)
	return reply, err
}

// Disconnect is client rpc method as defined
func (c *SessClient) Disconnect(ctx context.Context, args *DisconnectReq) (reply *DisconnectRsp, err error) {
	reply = &DisconnectRsp{}
	err = c.xclient.Call(ctx, "Disconnect", args, reply)
	return reply, err
}

// Heartbeat is client rpc method as defined
func (c *SessClient) Heartbeat(ctx context.Context, args *HeartbeatReq) (reply *HeartbeatRsp, err error) {
	reply = &HeartbeatRsp{}
	err = c.xclient.Call(ctx, "Heartbeat", args, reply)
	return reply, err
}

// GetOnline is client rpc method as defined
func (c *SessClient) GetOnline(ctx context.Context, args *GetOnlineReq) (reply *GetOnlineRsp, err error) {
	reply = &GetOnlineRsp{}
	err = c.xclient.Call(ctx, "GetOnline", args, reply)
	return reply, err
}

//================== oneclient stub ===================
// SessOneClient is a client wrapped oneClient.
type SessOneClient struct {
	serviceName string
	oneclient   *client.OneClient
}

// NewSessOneClient wraps a OneClient as SessOneClient.
// You can pass a shared OneClient object created by NewOneClientForSess.
func NewSessOneClient(oneclient *client.OneClient) *SessOneClient {
	return &SessOneClient{
		serviceName: "Sess",
		oneclient:   oneclient,
	}
}

// ======================================================

// Login is client rpc method as defined
func (c *SessOneClient) Login(ctx context.Context, args *LoginReq) (reply *LoginRsp, err error) {
	reply = &LoginRsp{}
	err = c.oneclient.Call(ctx, c.serviceName, "Login", args, reply)
	return reply, err
}

// Logout is client rpc method as defined
func (c *SessOneClient) Logout(ctx context.Context, args *LogoutReq) (reply *LogoutRsp, err error) {
	reply = &LogoutRsp{}
	err = c.oneclient.Call(ctx, c.serviceName, "Logout", args, reply)
	return reply, err
}

// Disconnect is client rpc method as defined
func (c *SessOneClient) Disconnect(ctx context.Context, args *DisconnectReq) (reply *DisconnectRsp, err error) {
	reply = &DisconnectRsp{}
	err = c.oneclient.Call(ctx, c.serviceName, "Disconnect", args, reply)
	return reply, err
}

// Heartbeat is client rpc method as defined
func (c *SessOneClient) Heartbeat(ctx context.Context, args *HeartbeatReq) (reply *HeartbeatRsp, err error) {
	reply = &HeartbeatRsp{}
	err = c.oneclient.Call(ctx, c.serviceName, "Heartbeat", args, reply)
	return reply, err
}

// GetOnline is client rpc method as defined
func (c *SessOneClient) GetOnline(ctx context.Context, args *GetOnlineReq) (reply *GetOnlineRsp, err error) {
	reply = &GetOnlineRsp{}
	err = c.oneclient.Call(ctx, c.serviceName, "GetOnline", args, reply)
	return reply, err
}
